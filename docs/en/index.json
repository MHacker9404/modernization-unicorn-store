[
{
	"uri": "/en/10-intro.html",
	"title": "What and Why",
	"tags": [],
	"description": "",
	"content": "Before you dive head first into running the labs, please spend few minutes perusing this section to find out what this content is and isn\u0026rsquo;t, what type of professional will benefit from using it, what is required for running lab modules of this workshop and how to be productive and have fun.\n"
},
{
	"uri": "/en/10-intro/05-target-audience.html",
	"title": "Who this Workshop is For",
	"tags": [],
	"description": "",
	"content": "Anyone comfortable with Visual Studio or Jetbrains Rider is going to have easy time with this workshop. Proficiency with C# is quite important and familiarity with Amazon Web Services is beneficial too.\nThis is level 300-400 (intermediate to advanced) workshop, so please do not assume \u0026ldquo;Hello, World\u0026rdquo; simplicity.\n.NET developers, especially those writing web applications, are those who will benefit most from using this workshop. You don\u0026rsquo;t have to be seasoned engineer though to learn and enjoy from this content: even an intermediate or an ambitious beginner should have no trouble working through the most labs.\nOther technical roles, like Architects, DevOps, Site Reliability Engineers, with some familiarity with .NET software development ecosystem, should also have easy time following lab steps and learning how a run-of-the-mill ASP.NET application can be modernized and ripping benefits from moving to the cloud.\n"
},
{
	"uri": "/en/20-cdk/10-overview.html",
	"title": "CDK Module Overview",
	"tags": [],
	"description": "",
	"content": " Welcome to the .NET AWS CDK module of the workshop!\nWorkshop Goals The goal of this lab is to guide participants through adding support for MySQL database to both ASP.NET application codebase, and to the existing infra-as-code C# CDK projects defining cloud CI/CD pipeline and cloud application deployment environment.\nThis workshop skips the \u0026ldquo;Hello, World\u0026rdquo; CDK project creation, and instead focuses on somewhat more in-depth capabilities of the CDK, showing higher-fidelity code samples implementing closer-to-real-life scenarios. This means that the lab will start with a couple of existing, but still pretty small CDK projects, and the lab flow focuses on modifying these projects.\nThe aim is to help you learn how to take your cloud-unaware ASP.NET Core application and use C# to write code defining parts of:\n CI/CD pipeline infrastructure in AWS cloud that builds and deploys the application. AWS cloud application deployment infrastructure, including an application hosting components and a database: Amazon Elastic Container Service (ECS Fargate) and Amazon Relational Database Service (RDS) hosting a selection of popular relational databases like Aurora MySQL (HA), Aurora Postgres (HA), and SQL Server.   If you find yourself struggling with the lab or running into unexpected errors, you may skip ahead by checking out cdk-module-completed Git branch, where all changes required for adding MySQL support are already implemented.\n CKD Demystified  AWS Cloud Development Kit is higher-level abstraction components built on top of the Amazon CloudFormation - an indispensible previous-generation infrastructure-as-code service, with the major difference that CDK lets programmers use most of their favorite programming languages, like C#, to generate CloudFormation templates while writing order of magnitude less code than with CloudFormation.\n CDK consists of a CLI and a set of libraries available for most popular programming languages. In the case of .NET CDK, the libraries are added via NuGet.\nA .NET CDK project is a Console app, generating AWS CloudFormation template. CDK CLI is a convenience tool making it possible to bypass direct contact with lower-level CloudFormation templates and related commands of AWS CLI.\n"
},
{
	"uri": "/en/10-intro/10-overview.html",
	"title": "What&#39;s Inside",
	"tags": [],
	"description": "",
	"content": " ASP.NET Application The foundation of every module here is an ASP.NET Core Unicorn Store web application that has an MVC/Razor UI and MVC Controllers implementing business logic and data access layers. Unicorn Store application is based on an established ASP.NET Music Store sample and thus should be fairly familiar to many participants.\nData Access components of the application are written using code-first style, enabling easy switching of the DAL from using SQL Server to other RDBMS, including open-source databases like MySQL and PostgreSQL.\nCI/CD Pipeline and Deployment Environment Infra As Code All workshop modules feature AWS CI/CD pipeline infrastructure and deployment environment infrastructure as expressed as AWS CDK based C# code, thus enabling an easy building and deployment of the application in AWS cloud.\n"
},
{
	"uri": "/en/20-cdk.html",
	"title": "AWS .NET CDK",
	"tags": [],
	"description": "",
	"content": " Welcome to the Infrastructure-as-C#-Code!  This module covers several facets of modern application development, namely using the .NET flavor of the AWS Cloud Development Kit (CDK) for creating cloud-based CI/CD pipeline for building and deploying an ASP.NET application, as well as for creation of an application cloud deployment/hosting environment.\nLevel: 300-400 (not a \u0026ldquo;Hello, World\u0026rdquo;)\n "
},
{
	"uri": "/en/",
	"title": "ASP.NET Modernization Workshop",
	"tags": [],
	"description": "",
	"content": " This site comprises a set of workshop modules created to showcase how an ASP.NET application can be converted from being an IIS and SQL Server bound monolith into a modern cross-platform application capable of running in the cloud.\nPlease use either navigation arrows on each sides of the page, or the Table of Contents on the left, to move around and find material that is most useful for you.\nDisclaimer Using AWS resources may result in resource usage and other charges if you are using your personal or corporate AWS accounts.\n"
},
{
	"uri": "/en/20-cdk/20-setting-up.html",
	"title": "Setting Up Dev Environment",
	"tags": [],
	"description": "",
	"content": " You may skip this page and move on to the next step and you are using Amazon-supplied VM image (AMI) at an Amazon event, with all tools installed and pre-configured.\nPre-Requisites  Either MS SQL Server (LocalDB version is perfectly suitable), or PostgreSQL, per Common Prerequisites. MySQL is required as the goal of the module is to add MySQL support to the app. MySQL Workbench, a MySQL management UI console, is recommended.   For Windows Users Only:\n  Chocolatey package manager. The jq utility that parses JSON.  Checking Out Source Code In a directory of your choice, please run\ngit clone https://github.com/vgribok/modernization-unicorn-store.git git checkout cdk-module Building and Running Unicorn Store Application Locally  Open Visual Studio solution:\ncd modernization-unicorn-store UnicornStore.sln In VS Solution Explorer, click the Collapse All [-] icon to clean up the tree view and select UnicornStore.csproj as a Startup Project.\n Choose build configuration for your choice of RDBMS:\n     Build Configurations Notes      You can use either MS SQL Server or PostgreSQL as a database at this point in the lab flow. (MySQL is not yet available at this point as it\u0026rsquo;s a new RDBMS to add support for as a part of this lab.) When using SQL Server LocalDb, no application configuration setting changes are necessary. You may simply select \u0026ldquo;DebugSqlServer\u0026rdquo; build configuration from the drop-down and run the application. For PostgreSQL, please select \u0026ldquo;DebugPostgres\u0026rdquo; from the build configuration drop down in the IDE.    Application Configuration for PostgreSQL You may skip this section if you plan to use MS SQL Server as a RDBMS for the application.\nIf you choose PostgreSQL as application\u0026rsquo;s RDBMS, additional changes in application settings will need to be made so that application could connect to a database other than local SQL Server with integrated authentication.\n   Notes Secret Manger     Please open UnicornStore project Secret Manager by right-clicking on the project and selecting Manage User Secrets menu item. It will open secrets.json file in Visual Studio, where you can make changes as it was the appsettings.json file.  Changes made in \u0026ldquo;secrets.json\u0026rdquo; override values stored in the \u0026ldquo;appsettings.json\u0026rdquo; files at run time, without making any changes to the \u0026ldquo;appsettings.json\u0026rdquo;.     Application setting named UnicornDbConnectionStringBuilder represents properties from RDBMS-specific subclasses of the DbConnectionStringBuilder. Since the plan here is to use PostgreSQL, properties of the \u0026ldquo;UnicornDbConnectionStringBuilder\u0026rdquo; section will represent properties of the NpgsqlConnectionStringBuilder class.\n{ \u0026#34;DefaultAdminUsername\u0026#34;: \u0026#34;Administrator@test.com\u0026#34;, \u0026#34;DefaultAdminPassword\u0026#34;: \u0026#34;Secret1*\u0026#34;, \u0026#34;UnicornDbConnectionStringBuilder\u0026#34;: { \u0026#34;Password\u0026#34;: \u0026#34;\u0026lt;YOUR POSTGRES PASSWORD\u0026gt;\u0026#34;, } } Please replace the content of the \u0026ldquo;secrets.js\u0026rdquo; file open in the Visual Studio, with the code snippet above, and replace the value of the Password property with your local Postgres password. Don\u0026rsquo;t forget to save the file before moving on to the next section of the lab.\n"
},
{
	"uri": "/en/10-intro/20-prerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "  To successfully execute any module of this workshop, following common requirements need to be fulfilled, in addition to any module-specific requirements outlined in each module guide.\nIf you are taking this lab within the scope of an Amazon event, in many cases a remote VM with all necessary prerequisites will be made available for workshop participants, so you may skip this chapter altogether. (Mac users, to access remote Windows VM, please ensure you have Remote Desktop Client installed).\n Note to non-Windows users: since most modules are based on .NET Core version of the application, Mac and Linux users should have no trouble executing most modules. Mac users should be able to use either Visual Studio for Mac, or Jetbrains Rider for an IDE. Linux users should use Jetbrains Rider IDE. Also, some of the links below target Chocolatey - Windows package manager, Mac and Linux users could simply switch to Homebrew or yum/apt/etc package managers respectively.\n(Although it is possible to use just dotnet CLI for this workshop, for simplicity and efficiency sake we dare to assume that takers of this 300-400 level workshop focusing on software development already know how to install their most basic tools, so that this workshop could skip IDE etc. installation steps boilerplate.)\nSoftware Required for Most Modules  .NET Core Framework 2.2. Visual Studio 2019 Community Edition or any other IDE capable of building and running Visual Studio solutions. An RDBMS like MySQL, PostgreSQL or MS SQL Server LocalDB, along with a corresponding management console, will be required for most modules. AWS account to run the lab in the AWS could. AWS CLI to interact with AWS services from your system. Node.js and AWS CDK for building infrastructure-as-code projects that are part of the solution. Git for pushing lab code to the cloud CI/CD pipeline for deployment.  The list above provides good baseline for your environment, but some modules will have additional requirements specified in the introduction section of each module.\n"
},
{
	"uri": "/en/20-cdk/30-running-app-locally.html",
	"title": "Running App Locally",
	"tags": [],
	"description": "",
	"content": " Starting Unicorn Store Web Application     Notes      Once you have prepared your development environment, the only thing remains is to ensure that UnicornStore.csproj is selected as a startup project, switch hosting from \u0026ldquo;IIS Express\u0026rdquo; to Console, as shown on the screenshot on the left, and start the application in the debug mode.    After debugging session has started, a command console window will open first with application console output in it, along with a web browser window, showing the home page of the Unicorn Store ASP.NET application.    Exploring and Testing Unicorn Store Web Application Functionality Unicorn Store is an emulation of an e-commerce web site implementing simplified product catalog, shopping cart and checkout flow.\nAfter you have started the application, you should see the home page shown on the screenshot above. At the bottom of the screen you should see RDBMS type and database server address information.\nPlease add a few unicorns to the basket, and click the \u0026ldquo;Checkout \u0026gt;\u0026gt;\u0026rdquo; button at the top of the shopping cart page. You will be prompted to log in. Please use credentials saved in the \u0026ldquo;secrets\u0026rdquo; file at the previous step: \u0026ldquo;Administrator@test.com\u0026rdquo; for username, and \u0026ldquo;Secret1*\u0026rdquo; for the password. To complete checkout flow, please enter shipping address, and for payment simply enter \u0026ldquo;FREE\u0026rdquo; in the \u0026ldquo;Promo Code\u0026rdquo; field and click \u0026ldquo;Submit Order\u0026rdquo; - if all went as planned, you should see the \u0026ldquo;Checkout Complete\u0026rdquo; message.\n"
},
{
	"uri": "/en/10-intro/30-dotnet-secrets.html",
	"title": ".NET Core Secret Manager",
	"tags": [],
	"description": "",
	"content": " An important note on using .NET Core Secret Manager:\n This lab makes an extensive use of .NET Core Secret Manager on your development workstation to save database passwords and similar types of sensitive application configuration data that varies from one developer\u0026rsquo;s workstation to another. Please note that despite the name .NET Core Secret Manager is not secure! It does not encrypt or password-protect your sensitive data. .NET Secrets are just plain text JSON files stored in a well-known directory. All they do is:\n Allow saving applications settings data outside of project root, eliminating the risk of committing your sensitive appsettings data inadvertently, and Provide one more layer in appsettings.json hierarchy.  One can think of .NET Core Secret Manager as just a way to alter appsettings.json at development time, without modifying actual appsettings.json or launchsettings.json, or without having to save setting values as environment variables.\n"
},
{
	"uri": "/en/20-cdk/40-creating-ci-cd-pipeline.html",
	"title": "Creating AWS CI/CD Pipeline",
	"tags": [],
	"description": "",
	"content": " Before we dive into the code base of the Unicorn Store solution and start hacking it, let\u0026rsquo;s spend a few moments to create the CI/CD pipeline in AWS, as creating it takes a few minutes to complete, and while that is in progress, we\u0026rsquo;ll spend some time looking into the structure of project and getting familiar with CDK concepts.\n    Notes      Again, please select either Posgres or SQL Server configuration from Solution\u0026rsquo;s Build Configuration drop-down in Visual Studio\u0026hellip;    \u0026hellip;and mark \u0026ldquo;CicdInfraAsCode\u0026rdquo; project as a startup project.Please run the project. If all went well you should see a console window with output starting with something like Synthesized to \u0026ldquo;C:\\Users\\username\\AppData\\Local\\Temp\\cdk.outjLaGkJ\u0026rdquo;. That path is the location of where CloudFormation templates generated.    Launching CI/CD Pipeline Infrastructure Creation Now please open a Command Prompt window and cd into the directory containing \u0026ldquo;CicdInfraAsCode.csproj\u0026rdquo; project file, which relative to the solution root is in \u0026ldquo;infra-as-code/CicdInfraAsCode/src\u0026rdquo;.\n If you never ran cdK CLI before in the currently-configured AWS Region, and you are not using an AWS event supplied VM, you may need to run cdk bootstrap command that runs a CloudFormation template that configures some resources required for the CDK to function. This is a one-time thing per AWS region.\n Next, run the following command to start creation of the CI/CD pipeline:\ncdk deploy --require-approval never That will start a process of creating a CI/CD pipeline for the application using AWS CodePipeline service, which in turn orchestrates few other AWS services, like CodeCommit and CodeBuild. This CI/CD infrastructure build-out job should take a few minutes, which will be well spent in the next section, which deals with the structure of the project.\n"
},
{
	"uri": "/en/20-cdk/50-project-structure.html",
	"title": "Project Structure",
	"tags": [],
	"description": "",
	"content": " Let\u0026rsquo;s use the few minutes that it takes for the application CI/CD pipeline infrastructure to build, to get familiar with the structure of the project.\n    Notes      Solution contains one ASP.NET Core application project named UnicornStore, and three CDK-related projects: CdkLib - a C# class library project, containing reusable components shared between two executable CDK projects.    The first of executable CDK projects is CicdInfraAsCode - the project we ran at the previous step of the lab. \u0026ldquo;CicdInfraAsCode\u0026rdquo; is a C# Console project, generating CloudFormation templates from C# code, to build out AWS CodePipeline CI/CD infrastructure.\n The \u0026ldquo;CicdInfraAsCode\u0026rdquo; project contains a small Node.js sub-project in the \u0026ldquo;/assets/lambda/ecs-container-recycle\u0026rdquo; directory, which defines serverless AWS Lambda function used at the final stage of the CI/CD pipeline to recycle Linux containers, after new container image is built and made available to the application hosted by Amazon ECS.\n Second executable CDK project is ProdEnvInfraAsCode - an C# Console project, generating CloudFormation templates that build out Unicorn Store application deployment environment in AWS cloud. This project will not be run from the Visual Studio because it will be run from the AWS CodePipeline to deploy Unicorn Store application packaged as a Linux container to Amazon Elastic Cloud Service (ECS), and to provision an RDBMS instance for the application from Amazon Relational Database Service (RDS).\nUnicorn Store ASP.NET Core Application Overview A descendant from a well-known ASP.NET Music Store sample, Unicorn Store is created to be a fairly typical ASP.NET Core 2.x MVC/Razor \u0026amp; Entity Framework Core application, combining UI, business logic and data access tiers in a single application, which is arguably a very typical design for most ASP.NET applications pre-dating microservices, 12-factor/cloud-native applications, and as such, suitable for modernization-focused labs.\n Something worth noting: Unicorn Store application project has no dependencies on any AWS components. The goal of the sample project is to represent an application that has only open-source dependencies and thus can run anywhere, from local developer workstation, to a proprietary datacenter, to any cloud service provider.\n Unicorn Store data access tier is designed using code-first style, which uses C# code to define entity relationships and consequently database structure. This approach enables relatively easy swapping of database engines without drastically affecting the codebase. This module starts with the application codebase already retrofitted with pluggable RDBMS architecture and supporting SQL Server and PostgreSQL database engines out of the box.\nThis lab\u0026rsquo;s focus is on adding support for MySQL database, which is a pretty simple task enabled by most of database engine configuration code abstracted away and already implemented. This relative simplicity will let us focus on the CDK-related tasks in later chapters.\nCDK Projects Overview CdkLib CdkLib, a shorthand for CDK library, contains modest amount of reusable C# code referenced by both executable .NET CDK projects. It\u0026rsquo;s home to classes and helper methods reducing amount of boilerplate, making infrastructure build-out \u0026ldquo;meat\u0026rdquo; code in main projects more concise and expressive. It also serves as an illustration that CDK code is very easy to componentize and parameterize.\nOne of the most useful bits in the CdkLib project is helper methods loading standard .NET Core IConfiguration from appsettings.json, environment variables, command line args and .NET Secret Manager, and deserialized into a strongly-typed class compatible with main CDK stack setting marshalling interface. This makes it ver easy to pass parameters to CDK projects via Environment variables in CodePipeline, CodeBuild and other places.\nProdEnvInfraAsCode This project is a .NET CDK Console application project responsible for generating AWS CloudFormation templates that create Unicorn Store application hosting environment. The hosting environment, at the high level, consists of the Amazon Elastic Container Service (ECS) and Relational Database Service (RDS). Under the hood the infrastructure built by this project is more complex, including various networking components, like a load balancer, virtual private cloud, subnets, security groups (firewall rules), roles and others.\nHowever, despite the sophistication of the cloud infrastructure produced by this project, the amount and complexity of the code required to implement it is strikingly low.\n ProdEnvInfraAsCode project is going to be run by the \u0026ldquo;build\u0026rdquo; part of the CI/CD pipeline, and not manually by developers, except for debugging purposes discussed in later chapters.\n Architectural Diagram of the Application Hosting Environment CicdInfraAsCode The more complex of all CDK projects, still with only about 300 lines of CDK code (plus another 100 lines of Node.js code), this C# Console app project produces three-stage project build and deployment pipeline, show below.\nAt high level, the CI/CD pipeline infrastructure includes Amazon CodePipeline, CodeCommit - a Git repository service, CodeBuild, Elastic Container Registry (ECR), and Lambda services.\nThe Build stage of the pipeline contains two parallel sub-stages: a) building application and packaging its artifacts as a Docker container image, and b) compiling and running second CDK project, the \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo;, which builds out deployment infrastructure for hosting Unicorn Store app.\nThe pipeline is not overly complicated and does not yet contain any quality gates, like testing, but it can serve as a springboard for an evolving CI/CD pipeline project.\nThe project contains a Node.js sub-project in the \u0026ldquo;/src/assets/lambda/ecs-container-recycle\u0026rdquo;, which implements a serverless AWS Lambda function that is invoked by the final stage of the CI/CD pipeline to restart the ECS-hosted Unicorn Store application to load newly-minted application build.\nThe size of the Node.js code-base is fairly modest, and the code is split between the \u0026ldquo;cdklib\u0026rdquo; directory, where reusable and potentially boilerplate code is sequestered, and the \u0026ldquo;index.js\u0026rdquo; file, where the man logic of the function is implemented.\n At this point, please spend 5-10 minutes browsing through the UnicornStore solution and to familiar with where major parts of the codebase located.\n Now that we\u0026rsquo;ve taken the tour of the project, let\u0026rsquo;s move to the next chapter to see whether our CI/CD infrastructure has finished building.\n"
},
{
	"uri": "/en/20-cdk/60-starting-cicd-build.html",
	"title": "Starting Pipeline Build",
	"tags": [],
	"description": "",
	"content": " At this point the CI/CD pipeline cloud infrastructure, the build out of which was launched two chapters back, should now be completed.\nFirst, please check the command prompt console where you ran cdk deploy for the \u0026ldquo;CicdInfraAsCode\u0026rdquo; project, to make there were errors. You should see something like the following at the tail of the output after command has finished:\n 30/30 | 1:10:43 PM | CREATE_COMPLETE | AWS::CloudFormation::Stack | Unicorn-Store-CI-CD-PipelineStack ✅ Unicorn-Store-CI-CD-PipelineStack Stack ARN: arn:aws:cloudformation:us-east-1:123456789012:stack/Unicorn-Store-CI-CD-PipelineStack/eee6e58c-6808-48a2-9885-c719f44dd8b6  Next, navigate to the CodePipeline in the AWS Console and observe \u0026ldquo;Unicorn-Store-CI-CD-Pipeline\u0026rdquo; in the list, showing the \u0026ldquo;Failed\u0026rdquo; status next to it. The pipeline is in the failed state because the source code of the Unicorn Store solution has not yet been pushed to the CodeCommit Git repository.\nPlease click on the \u0026ldquo;Unicorn-Store-CI-CD-Pipeline\u0026rdquo; link to see the never-run pipeline: Starting the Pipeline: Pushing Source Code to CodeCommit To trigger the build and deployment pipeline, all we need to do is to push the Unicorn Store to the CodeCommit Git repository just created.\n Following step - adding Git \u0026ldquo;remote\u0026rdquo; (alias) pointing to the CodeCommit repository, can be skipped if you are taking this lab at an AWS event, as the \u0026ldquo;aws\u0026rdquo; Git remote is already on your dev VM.\n Windows users, please use Powershell in Administrator mode for running commands that follow.\n First, cd into the root of the Unicorn Store solution. Create Git \u0026ldquo;remote\u0026rdquo; named \u0026ldquo;aws\u0026rdquo;:\ngit remote add aws (aws codecommit get-repository --repository-name Unicorn-Store-Sample-Git-Repo | jq -r .repositoryMetadata.cloneUrlHttp) Push the code to the CodeCommit repository:\ngit push aws cdk-module Observe CodePipeline Build in-progress by waiting half a minute or so and then going to the CodePipeline page in the AWS Console:    First run of the pipeline is likely to take approximately 15 minutes, primarily due to time required to provision application database and ECS-based application hosting infrastructure. Subsequent pipeline runs cas run to completion in under one minute.\n "
},
{
	"uri": "/en/20-cdk/63-verify-ci-cd-completion.html",
	"title": "Verify Pipeline Run Completion",
	"tags": [],
	"description": "",
	"content": " While the pipeline is busy building the application and provisioning application hosting infrastructure, we have about 15-20 minutes to start hacking the app and CDK project, adding MySQL support to it. Feel free to go to the next chapter and come back here later to ensure the pipeline is alright.\nVerifying the CI/CD Pipeline Run Has Completed Whenever the pipeline has finished, feel free to browse to the AWS Load Balancer page in the AWS Console, select a load balancer named \u0026ldquo;unicorn-store\u0026rdquo; and click the \u0026ldquo;copy to clipboard\u0026rdquo; icon next to the \u0026ldquo;DNS Name\u0026rdquo; field.\nThen paste the URL into a new browser tab, hit Enter and observe Unicorn Application home page loaded: Verifying the Unicorn Store App Running on AWS To verify that nothing is broken, please add a few unicorns to the basket, and click the \u0026ldquo;Checkout \u0026gt;\u0026gt;\u0026rdquo; button at the top of the shopping cart page. You will be prompted to log in. Although site administrator username username has not changed and remains \u0026ldquo;Administrator@test.com\u0026rdquo;, password is was not specified explicitly in the hosting environment infrastructure project configuration or anywhere else for that matter. Instead, password was stored using Amazon Secrets Manager service.\nTo retrieve site admin password from AWS Secrets Manager, please run this command:\naws secretsmanager get-secret-value --secret-id UnicornSuperstoreDefaultSiteAdminPassword | jq -r .SecretString Copy the output of the command to the clipboard and use it as password to log in to the site.\nTo complete checkout flow, please enter shipping address, and for payment simply enter \u0026ldquo;FREE\u0026rdquo; in the \u0026ldquo;Promo Code\u0026rdquo; field and click \u0026ldquo;Submit Order\u0026rdquo; - if all went as planned, you should see the \u0026ldquo;Checkout Complete\u0026rdquo; message.\n"
},
{
	"uri": "/en/20-cdk/65-adding-mysql-support.html",
	"title": "MySQL Support",
	"tags": [],
	"description": "",
	"content": "This chapter will guide you through the process of adding support for MySQL to the Unicorn Store application and to infra-as-code projects. MySQL is an open source, cross-platform, relational database that can be run in a cloud, on premises, or locally on developer workstation free of charge.\nThis set of steps builds on the existing, multi-database-friendly architecture of the Unicorn Store application, which already supports MS SQL Server and open-source PostgreSQL, while requiring only modest changes to the code of executable projects in the Solution.\n"
},
{
	"uri": "/en/20-cdk/67-app-nuget-and-appsettings.html",
	"title": "App: NuGet and AppSettings",
	"tags": [],
	"description": "",
	"content": "  This chapter assumes that MySQL is installed locally.\n Adding MySQL Library to the Application via NuGet  Please start with marking \u0026ldquo;UnicornStore\u0026rdquo; project as a Startup Project in Visual Studio. Open \u0026ldquo;Package Manager Console\u0026rdquo; by selecting it from the \u0026ldquo;View | Other Windows\u0026rdquo; menu. Install Pomelo.EntityFrameworkCore.MySql version 2.2 package by running following command in Visual Studio \u0026ldquo;Package Manager Console\u0026rdquo;:\nInstall-Package Pomelo.EntityFrameworkCore.MySql -Version 2.2.0  Adding Default Connection String String to \u0026ldquo;appSettings.json\u0026rdquo; Open \u0026ldquo;appSettings.json\u0026rdquo; file of the \u0026ldquo;UnicornStore\u0026rdquo; project and add following entry to the \u0026ldquo;ConnectionStrings\u0026rdquo; section.\n\u0026#34;UnicornStoreMySQL\u0026#34;: \u0026#34;Server=localhost;Database=UnicornStore;Uid=root;Pwd=NeverEVERsavePasswordInConfigFiles;\u0026#34; Don\u0026rsquo;t forget the comma before or after the \u0026ldquo;UnicornStoreMySQL\u0026rdquo; property.\n"
},
{
	"uri": "/en/20-cdk/69-updating-build-config.html",
	"title": "Updating Build Config",
	"tags": [],
	"description": "",
	"content": "Before anything else, we need to update solution-to-project Build Configuration mapping.\n    Notes      Please start with bringing up Solution Configuration Manager.    Then select \u0026ldquo;DebugMySQL from the \u0026ldquo;Active solution configuration dropdown and change executable project configuration mapping from \u0026ldquo;DebugProject\u0026rdquo; to \u0026ldquo;DebugMySQL\u0026rdquo;:\n           Changeto =\u0026gt;     Please do the same for the ReleaseMySQL solution configuration: map executable project context configuration to \u0026ldquo;ReleaseMySQL\u0026rdquo;\n FYI, each project that has \u0026ldquo;XxxxxMySQL\u0026rdquo; configuration, has MYSQL conditional compilation constant defined for the project: (Same is true for \u0026ldquo;XxxxxPostgres\u0026rdquo; and \u0026ldquo;XxxxxSqlServer\u0026rdquo;: they have POSTGRES and SQLSERVER respective build constants defined.)\nThe process of creating \u0026ldquo;DebugMySQL\u0026rdquo; and \u0026ldquo;ReleaseMySQL\u0026rdquo; project build configurations is tedious and not very relevant for this module, so these two project build configurations are provided out of the box, rather than guiding lab participants here to create them manually.\n Finally, please ensure DebugMySQL solution configuration is selected in the \u0026ldquo;Solution Configurations\u0026rdquo; dropdown.\n"
},
{
	"uri": "/en/20-cdk/71-modifying-startup-cs.html",
	"title": "Modifying Startup.cs",
	"tags": [],
	"description": "",
	"content": " Please open \u0026ldquo;Startup.cs\u0026rdquo; file of the \u0026ldquo;UnicornStore\u0026rdquo; project in Visual Studio. Add using MySql.Data.MySqlClient; line to top part of the file. Find ConfigureDatabaseEngine() method and replace the #if POSTGRES line in it with\n#if MYSQL  this.HookupMySQL(services); #elif POSTGRES  Now, to implement missing \u0026ldquo;HookupMySQL()\u0026rdquo; function, find the HookupPostgres() method and replace the #if POSTGRES line right above it with\n#if MYSQL  private void HookupMySQL(IServiceCollection services) { #if Debug || DEBUG  // The line below is a compile-time debug feature for `docker build` outputting which database engine is hooked up #warning Using MySQL for a database #endif  this.HookupDatabase\u0026lt;MySqlConnectionStringBuilder, MySqlDbContextOptionsConfigurator\u0026gt;(services, \u0026#34;MySQL\u0026#34;); } #elif POSTGRES   \u0026ldquo;HookupMySQL()\u0026rdquo; method does two things:\n Adds compile-time output reporting MySQL being the RDBMS type the project is compiled for. Registers MySQL database engine services with .NET Core IoC container (IServiceCollection), specifically ir registers stock MySqlConnectionStringBuilder from the MySQL library added via NuGet, and proprietary MySqlDbContextOptionsConfigurator that we are about to implement on the next step. HookupDatabase() is a reusable method, which among a few others was written for this workshop with aim to achieve Database Freedom, i.e. break original application\u0026rsquo;s dependency on SQL Server and make it compatible with wide array of open source database engines, which also makes the application compatible with Amazon RDS and Aurora services.  "
},
{
	"uri": "/en/20-cdk/73-mysqldbcontextoptionsconfigurator.html",
	"title": "MySQL Options Configurator",
	"tags": [],
	"description": "",
	"content": "Each database engine supported by the Unicorn Store application needs a DbContextOptionsConfigurator subclass. \u0026ldquo;DbContextOptionsConfigurator\u0026rdquo; facilitates deferred and dynamic update of stored database connection information in case when connection string information stored in the \u0026ldquo;appsettings.json\u0026rdquo; file changes while the application is running.\n Unlike common practice shown in countless .NET Core samples, loading connection string once when Configure() method is called goes against the design goals of the IConfiguration-based settings handling, as doing so circumvents dynamic settings reloading capabilities of \u0026ldquo;IConfiguration\u0026rdquo;.\nTo work-around this somewhat deeply ingrained anti-pattern, a small set of classes was created to enable deferred loading and dynamic re-loading database connection information from the \u0026ldquo;appsettings.json\u0026rdquo;, without having to restart the application.\n  In the IDE, please expand the \u0026ldquo;UnicornStore\u0026rdquo; project tree, right-click the Configuration folder, and select \u0026ldquo;Add | Class\u0026rdquo; from the context menu. For class name, enter MySqlDbContextOptionsConfigurator.cs and hit Enter. Replace generated stock content of the file with\nusing Microsoft.EntityFrameworkCore; using Microsoft.Extensions.Logging; using System.Data.Common; namespace UnicornStore.Configuration { public class MySqlDbContextOptionsConfigurator : DbContextOptionsConfigurator { public MySqlDbContextOptionsConfigurator( DbConnectionStringBuilder dbConnectionStringBuilder, ILogger\u0026lt;MySqlDbContextOptionsConfigurator\u0026gt; logger ) : base(dbConnectionStringBuilder, logger) { } public override string DbEngine =\u0026gt; \u0026#34;MySQL\u0026#34;; internal override void Configure(DbContextOptionsBuilder optionsBuilder) { base.Configure(optionsBuilder); optionsBuilder.UseMySql(this.dbConnectionStringBuilder.ConnectionString); } } }   As you have probably noticed, the only consequential line of code in the snippet above is\noptionsBuilder.UseMySql(this.dbConnectionStringBuilder.ConnectionString);  This line is the one usually called from the \u0026ldquo;Startup.cs\u0026rdquo;. Here the only thing we do differently is we defer calling UseMySql() to when \u0026ldquo;IConfiguration\u0026rdquo; becomes injectable, like you do it when you need \u0026ldquo;IConfiguration\u0026rdquo; in your MVC controller.\n Injecting \u0026ldquo;IConfiguration\u0026rdquo;, as it\u0026rsquo;s done in a typical MVC controller example, is the right way to use configuration settings. Manually loading connection string data, as often done in \u0026ldquo;Startup.cs\u0026rdquo;, breaks dynamic settings reload support. Mixing two mutually-exclusive approaches makes no practical sense, so we took this opportunity to make configuration settings data usage consistent across the entire ASP.NET application. Feel free to improve this logic and create a PR.\n "
},
{
	"uri": "/en/20-cdk/75-verifying-mysql-support-locally.html",
	"title": "Verifying MySQL Support",
	"tags": [],
	"description": "",
	"content": " Please be sure that \u0026ldquo;DebugMySQL\u0026rdquo; solution configuration is active. Build \u0026ldquo;UnicornStore\u0026rdquo; project - it should build without errors. Now we need to add your local MySQL connection information to the application settings in a non-destructive way, meaning without modifying \u0026ldquo;appSettings.json\u0026rdquo; or any other file in the solution root, which might lead to inadvertent committing credentials information to the version control system. To do this, we\u0026rsquo;ll use .NET Secret Manager. Please right-click \u0026ldquo;UnicornStore\u0026rdquo; project and select Manage User Secrets from the context menu. That will open \u0026ldquo;secrets.json\u0026rdquo; file in the IDE editor. Create or update UnicornDbConnectionStringBuilder entry in the \u0026ldquo;secrets.json\u0026rdquo; as follows\n{ \u0026quot;UnicornDbConnectionStringBuilder\u0026quot;: { \u0026quot;UserID\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;Password\u0026quot;: \u0026quot;\u0026lt;PASTE YOUR LOCAL MYSQL PASSWORD HERE\u0026gt;\u0026quot;, \u0026quot;ApplicationName\u0026quot;: \u0026quot;Unicorn Store AWS\u0026quot; } ... }   Please be sure to replace the value of the Password field with your local MySQL password and save the file. Run the \u0026ldquo;UnicornStore\u0026rdquo; project. If everything went well, you should see now-familiar Unicorn Store home page in the browser.     At the very bottom of the page you should see \u0026ldquo;MySQL database server address: localhost:3306\u0026rdquo; message. If you\u0026rsquo;ve got it, congratulations! You\u0026rsquo;ve just made this run-off-the-mill ASP.NET Core application work with a mature, multi-platform, open-source database engine, one implementation of which may give your database as much as 5x performance boost!\n "
},
{
	"uri": "/en/20-cdk/77-mysql-hosting-env-stack.html",
	"title": "Adding MySQL Support to the Hosting Env CDK Project",
	"tags": [],
	"description": "",
	"content": "  Next couple of sections will guide you through adding MySQL support to the ProdEnvInfraAsCode project that defines application cloud hosting environment using infrastructure-as-code approach.\nMySQL database underpinning Unicorn Store application is going to run in AWS cloud and is implemented either by Amazon RDS for MySQL or by Amazon Aurora service, depending whether the infrastructure is configured to run in a single-instance or in the cluster mode.\nAmazon RDS and Amazon Aurora are SQL Server, MySQL and PostgreSQL-compatible, managed, \u0026ldquo;serverless\u0026rdquo; services, capable of replacing self-managed RDBMS deployments running on unmanaged VMs or in containers. (AWS Aurora does not support SQL Server - only AWS RDS does).\n Please starting by marking \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; project inside the \u0026ldquo;infra-as-code\u0026rdquo; Visual Studio folder as a \u0026ldquo;Startup Project\u0026rdquo;.\nUpdating UnicornStoreDeploymentEnvStackProps.cs \u0026ldquo;UnicornStoreDeploymentEnvStackProps.cs\u0026rdquo; file holds configuration properties used by the CDK infra-as-code \u0026ldquo;stack\u0026rdquo;. We need make a few modest changes here.\n Open the \u0026ldquo;UnicornStoreDeploymentEnvStackProps.cs\u0026rdquo; file in the IDE editor. Find the DbEngineType enum and add MySQL entry to the enum. Find the DbEngine property and replace the #if POSTGRES line with\n#if MYSQL  DbEngineType.MySQL; #elif POSTGRES  Find the CreateDbConstructFactory() method and add the following to the top of the switch statement:\ncase DbEngineType.MySQL: return new MySqlConstructFactory(this);  At this point the only error on this page will be undefined MySqlConstructFactory() constructor from the class that will be implemented in the section below.\n  Implementing MySqlConstructFactory Class  Right-click Reusable folder under the \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; project in Visual Studio and select \u0026ldquo;Add | Class\u0026rdquo; from the context menu. For the class name, enter MySqlConstructFactory.cs and hit Enter. Replace generated stock implementation with\nusing Amazon.CDK.AWS.RDS; namespace ProdEnvInfraAsCode.Reusable { public class MySqlConstructFactory : DatabaseConstructFactory { public MySqlConstructFactory(UnicornStoreDeploymentEnvStackProps settings) :base(settings) { } protected override DatabaseInstanceEngine DbInstanceEgnine =\u0026gt; DatabaseInstanceEngine.MYSQL; protected override DatabaseClusterEngine DbClusterEgnine =\u0026gt; base.DbClusterEgnine ?? DatabaseClusterEngine.AURORA_MYSQL; protected override string ExistingAuroraDbParameterGroupName =\u0026gt; \u0026#34;default.aurora-mysql5.7\u0026#34;; internal override string DBConnStrBuilderUserPropName =\u0026gt; \u0026#34;UserID\u0026#34;; } }  This class supplies four settings for a handful of AWS RDS infrastructure settings:\n DatabaseInstanceEngine.MYSQL for the database instance engine, i.e. for when RDS service runs in a single-instance mode, as opposed to the cluster mode. DatabaseClusterEngine.AURORA_MYSQL for the database cluster engine, i.e. when RDS service runs in a cluster mode, and not in the single-instance mode. \u0026ldquo;default.aurora-mysql5.7\u0026rdquo; as a name of settings set known as a Parameter Group. Parameter Groups are maintained by AWS and are organized in a handful of pre-defined, named parameter sets made available to infrastructure builders. Here we select a most common, default set of parameters for the RDS MySQL. \u0026ldquo;UserID\u0026rdquo; here is the name of the property defining database user/login name in the Connection String Builder subclass for a specific database. Here it means that for MySQL, Connection String Builder property carrying database username is called \u0026ldquo;UserID\u0026rdquo;.    As you can see, \u0026ldquo;MySqlConstructFactory\u0026rdquo; pretty much in its entirety simply serves up a few overrides to the \u0026ldquo;DatabaseConstructFactory\u0026rdquo; base class, driving a few changes in how Unicorn Store database in AWS RDS is going to be configured.\n Verifying ProdEnvInfraAsCode Project Run the \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; project an ensure it did not throw any exceptions.\n"
},
{
	"uri": "/en/20-cdk/79-mysql-ci-cd-stack.html",
	"title": "MySQL in CI/CD CDK Project",
	"tags": [],
	"description": "",
	"content": " Here we\u0026rsquo;ll add MySQL support to the CI/CD CDK project.\n  Please start with marking \u0026ldquo;CicdInfraAsCode\u0026rdquo; project as a \u0026ldquo;Startup Project\u0026rdquo; in Visual Studio. Open \u0026ldquo;UnicornStoreCiCdStackProps.cs\u0026rdquo; file in the IDE editor. Find the DbEngineType enum and add MySQL entry to it. Find the DbEngine property and replace the #if POSTGRES line with\n#if MYSQL  DbEngineType.MySQL; #elif POSTGRES  Run the project to ensure there are no exceptions thrown.\n Open Command Prompt window and cd to the root of the \u0026ldquo;CicdInfraAsCode\u0026rdquo; project.\n Run cdk diff - command that compares currently existing the infrastructure (of the CI/CD pipeline in this case) created by the infra-as-code \u0026ldquo;stack\u0026rdquo; earlier, with the update infrastructure. You should see output looking like\nSynthesized to \u0026quot;cdk.out\u0026quot;. Stack Unicorn-Store-CI-CD-PipelineStack The Unicorn-Store-CI-CD-PipelineStack stack uses assets, which are currently not accounted for in the diff output! See https://github.com/aws/aws-cdk/issues/395 Resources [~] AWS::CodeBuild::Project CodeBuildProject CodeBuildProject4B91CF3F └─ [~] Environment └─ [~] .EnvironmentVariables: └─ @@ -54,7 +54,7 @@ [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;DbEngine\u0026quot;, [ ] \u0026quot;Type\u0026quot;: \u0026quot;PLAINTEXT\u0026quot;, [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot; [ ] }, [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;BuildConfig\u0026quot;, @@ -64,6 +64,6 @@ [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;ImageTag\u0026quot;, [ ] \u0026quot;Type\u0026quot;: \u0026quot;PLAINTEXT\u0026quot;, [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot; [ ] } [ ] ] [~] AWS::CodeBuild::Project DeploymentEnvCreationProject DeploymentEnvCreationProject70D82E6D └─ [~] Environment └─ [~] .EnvironmentVariables: └─ @@ -2,7 +2,7 @@ [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;DbEngine\u0026quot;, [ ] \u0026quot;Type\u0026quot;: \u0026quot;PLAINTEXT\u0026quot;, [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot; [ ] },  Please note parts reflecting the RDBMS type change in the output above:\n [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot;   cdk diff is a very, very useful tool, allowing developers to build-out an infrastructure base line, and then make changes to the infra-as-code project code and run \u0026ldquo;cdk diff\u0026rdquo; to see what will be changed in the cloud infrastructure if they run \u0026ldquo;cdk deploy\u0026rdquo;. That provides fast and non-destructive way of understanding what changes in the the infra-as-code project will be made by corresponding changes in the CDK project.\n Run cdk deploy --require-approval never and it should complete in a minute or two without errors, updating the CI/CD pipeline infrastructure in AWS with MySQL configured and the database engine.\n Now we need to trigger the pipeline by committing and pushing code changes to the AWS CodeCommit. For that please run git commit followed by git push aws and in a minute or so you should see the CI/CD pipeline executing.\n   Since hosting environment \u0026ldquo;stack\u0026rdquo; will now need to replace PostgreSQL database with MySQL database, it will again take roughly 15 minutes to complete the transition. Please keep monitoring the state of the pipeline, and once it finishes, please verify everything is well by using these steps.\n "
},
{
	"uri": "/en/20-cdk/81-explore-cdk-stack-source.html",
	"title": "Explore CDK Stack Source",
	"tags": [],
	"description": "",
	"content": "Now it\u0026rsquo;s perfect time to take a look at how a CDK \u0026ldquo;stack\u0026rdquo; written in C# looks like.\nFor best experience, please mark \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; as a Startup Project, open \u0026ldquo;Program.cs\u0026rdquo; in the IDE editor, put the break on the line with the `new UnicornStoreFargateStack(\u0026hellip;)\u0026rdquo; and start debugging.\nFirst you will skip over the straightforward-sounding LoadConfiguration() method that reads in \u0026ldquo;appSettings.json\u0026rdquo; etc. and passes loaded data to the UnicornStoreFargateStack(...) constructor in the settings variable.\nNext, with the debugger, step into the \u0026ldquo;UnicornStoreFargateStack(\u0026hellip;)\u0026rdquo; constructor. That\u0026rsquo;s where the highest-level flow creating Unicorn Store application hosting environment in its entirety, is defined.\n Please use the debugger to step inside every method you can in this project - it will only take five minutes or so to do that, but it will provide more insight info what CDK is all about than most of the \u0026ldquo;Hello, World\u0026rdquo; type of examples. This project is still pretty small in terms of code line count, but it provisions really sophisticated hosting environment.\nThe exercises of stepping through this project using debugger may be the most valuable activity of the entire Workshop.\n For those not inclined to step-debug through the code, here\u0026rsquo;s the screenshot of the main logic orchestrating application hosting environment creation at the highest level.\nIf you have experience with CloudFormation, you likely will appreciate ability to use imperative and object-oriented features of a real programming language, which may provision different resources depending on the execution path dictated by configuration settings.\n"
},
{
	"uri": "/en/20-cdk/95-thank-you.html",
	"title": "Thank You!",
	"tags": [],
	"description": "",
	"content": "This concludes the CDK module of the workshop. Thank you very much for your participation! We hope you have learned something new and useful today, and would not mind to let us know what we could improve.\nFeel free to explore further the codebase of all CDK projects to understand better the ins and outs of how to start building your own AWS infrastructure using all great features of C#.\nPlease don\u0026rsquo;t forget to clean up AWS resources created in the course of this lab! Doing that is especially important if you are using personal or corporate AWS Account, to ensure no unexpected charges are made for resources you have created.\n"
},
{
	"uri": "/en/20-cdk/99-cleanup.html",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": " Some manual clean up steps are required to delete resources created in the course of this module. You may need to follow these steps if you used your personal or corporate AWS Account.\nYou will also need to use these steps if you are taking this lab at an AWS event and you simply want to reset your cloud resources and restart the module from the beginning.\n When using your personal or corporate AWS Account, leaving resources created by this lab will result in recurring monthly charges for used resources.\nCommands below may remove most of the resources (no guarantees though) created in the course of this module.\n Delete Infrastructure \u0026ldquo;Stacks\u0026rdquo; Created by CDK Projects To see how CDK could be leveraged for cleanup, open a Command Prompt window and cd to the root of the \u0026ldquo;CicdInfraAsCode\u0026rdquo; project. Here run cdk destroy to effectively delete the CloudFormation stack produced by the project, which in turn destroys AWS resources comprising our CI/CD pipeline.\nAs an alternative, you may run\naws cloudformation delete-stack --stack-name Unicorn-Store-CI-CD-PipelineStack Since hosting environment stack was run as part of the CI/CD pipeline, deleting it is easily done with deleting the corresponding CloudFormation stack:\naws cloudformation delete-stack --stack-name UnicornSuperstoreStack Although both commands return instantaneously, the process of deleting resources up to 10 minutes, give or take. To see the progress, please browse to CloudFormation -\u0026gt; Stacks in AWS Console. There you should see DELETE_IN_PROGRESS status next to \u0026ldquo;UnicornSuperstoreStack\u0026rdquo; and \u0026ldquo;Unicorn-Store-CI-CD-PipelineStack\u0026rdquo; items. Refresh the page periodically using the round arrow icon.\nDelete KMS Key This section may become unnecessary after project is upgraded to CDK 1.13.\nBrowse to AWS Key Management Service at AWS Console, and enter \u0026ldquo;codepipeline-cicdinfraascodestackbuildpipelineb5eb558e\u0026rdquo; in the search box. Click the key entry and copy the Key ID guid value to the clipboard.\nNow remove the key alias and schedule the key for deletion\naws kms delete-alias --alias-name alias/codepipeline-cicdinfraascodestackbuildpipelineb5eb558e aws kms schedule-key-deletion --key-id \u0026lt;PASTE Key ID VALUE HERE\u0026gt; --pending-window-in-days 7 Delete ECR Docker Image Repository aws ecr delete-repository --repository-name unicorn-store-app --force"
},
{
	"uri": "/en/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/en/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]